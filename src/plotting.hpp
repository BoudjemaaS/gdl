/* *************************************************************************
   plotting.hpp  -  GDL routines for plotting
   -------------------
   begin                : July 22 2002
   copyright            : (C) 2002 by Marc Schellens
   email                : m_schellens@users.sf.net
 ***************************************************************************/

/* *************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/

#ifndef PLOTTING_HPP_
#define PLOTTING_HPP_

//for 3D transformations, with "our" plplot drivers.
#define PLESC_2D 99
#define PLESC_3D 100

#define gdlPlot_Min(a, b) ((a) < (b) ? (a) : (b))
#define gdlPlot_Max(a, b) ((a) > (b) ? (a) : (b))


//To debug Affine 3D homogenous projections matrices.
//IDL define a matrix as  M[ncol,mrow] and print as such. However col_major and
//row_major refer to the math notation M[row,col] where row=dim(0) and col=dim(1).
//Matrices are stored COL Major in IDL/Fortran and ROW Major in C,C++ etc.
//so element at (i,j) is computed as  (j*dim0 + i) for ColMajor/IDL
//and (i*dim1 + j) for RowMajor/C

#define TRACEMATRIX_C(var__)      \
  {int dim0__=(var__)->Dim(0), dim1__=(var__)->Dim(1);   \
    fprintf(stderr,"c matrix[%d,%d]\n",dim0__,dim1__);   \
    for (int row=0; row < dim0__ ; row++)    \
      {         \
  for (int col=0; col < dim1__-1; col++)    \
          {        \
            fprintf(stderr,"%g, ",(*var__)[row*dim1__ + col]);  \
          }        \
  fprintf(stderr,"%g\n",(*var__)[row*dim1__ + dim1__ -1]); \
      }         \
    fprintf(stderr,"\n");      \
  }
//The following abbrevs should output the C matrix as IDL would do (ie,transposed):
#define TRACEMATRIX_IDL(var__)      \
  {int dim0__=(var__)->Dim(0), dim1__=(var__)->Dim(1);   \
    fprintf(stderr,"idl matrix[%d,%d]\n[",dim0__,dim1__);  \
    for (int col=0; col < dim1__; col++)    \
      {         \
  fprintf(stderr,"[");      \
  for (int row=0; row < dim0__; row++)    \
          {        \
            fprintf(stderr,"%g",(*var__)[row*dim1__ + col]);  \
            if (row<dim0__-1) fprintf(stderr," ,");   \
            else if (col<dim1__-1) fprintf(stderr," ],$\n"); else fprintf(stderr," ]]\n") ; \
          }        \
      }         \
  }

#include "envt.hpp"
#include "graphicsdevice.hpp"
#include "initsysvar.hpp"

#ifdef USE_LIBPROJ
#include "projections.hpp"
#endif 

typedef enum {
  DATA = 0,
  NORMAL,
  DEVICE,
  NONE //for TV()
} COORDSYS;

typedef struct {
  DDouble zValue;
  DDouble T[16];
} GDL_3DTRANSFORMDEVICE;


static int code012[3] = {0, 1, 2};
static int code102[3] = {1, 0, 2};
static int code120[3] = {1, 2, 0};
static int code210[3] = {2, 1, 0};
static int code201[3] = {2, 0, 1};
static int code021[3] = {0, 2, 1};

enum T3DEXCHANGECODE {
  INVALID = -1,
  NORMAL3D = 0,
  XY,
  XZ,
  YZ,
};

// to be removed:
#define  SCALEBYDEFAULT 1./sqrt(3) 

static const DDouble ZVALUEMAX=0.99998999;

enum PLOT_AXES_IDENTIFIERS {
  XAXIS = 0,
  YAXIS,
  ZAXIS,
};

static const std::string axisName[6] = {"X", "Y", "Z", "X", "Y", "Z"};
#define DRAWAXIS "a"     //: Draw axis (X is horizontal line Y=0, Y is vertical line X=0)
#define BOTTOM "b"     //: Draw bottom (X) or left (Y) frame of box
#define TOP "c"     //: Draw top (X) or right (Y) frame of box
//#define "d"     //: Interpret axis as a date/time when writing labels
//#define "f"     //: Always use fixed point numeric labels
//#define "g"     //: Draws a grid at the major tick interval
//#define "h"     //: Draws a grid at the minor tick interval
#define TICKINVERT "i"     //: Inverts tick marks
#define LOG "l"     //: Logarithmic axes, major ticks at decades, minor ticks at units
#define NUMERIC_UNCONVENTIONAL "m"     //: Write numeric label at unconventional location
#define NUMERIC "n"     //: Write numeric label at conventional location
#define NUMERIC_UNCONVENTIONAL "m"     //: Write numeric label at unconventional location
#define LABELFUNC "o"     //: Label text is generated by a user-defined function
#define SUBTICKS "s"     //: Draw minor tick marks
#define TICKS "t"     //: Draw major tick marks
#define BOTTOM_NOLINE "u"     //: like b (including all side effects such as tick marks and numerical
// labels for those) except exclude drawing the edge.
#define TOP_NOLINE "w"     //: like c (including all side effects such as tick marks and numerical
// labels for those) except exclude drawing the edge.
#define YLABEL_VERTICAL "v"     //: (for Y only) Label vertically
#define NOTICKS "x"     //: like t (including the side effect of the numerical labels for the major
// ticks) except exclude drawing the major and minor tick marks.

#define GDL_NONE -1
#define GDL_TICKFORMAT 0
#define GDL_TICKUNITS 1
#define GDL_TICKFORMAT_AND_UNITS 2

struct GDL_TICKDATA {
  GDLGStream *a;
  bool isLog;
  DDouble axisrange; //to circumvent plplot passing a non-zero value instead of strict 0.0
  double nchars; //length of string *returned* after formatting. Can be non-integer.
};

struct GDL_TICKNAMEDATA {
  GDLGStream *a;
  bool isLog;
  DDouble axisrange; //to circumvent plplot passing a non-zero value instead of strict 0.0
  double nchars; //length of string *returned* after formatting. Can be non-integer.
  SizeT counter;
  SizeT nTickName;
  DStringGDL* TickName;
};

struct GDL_MULTIAXISTICKDATA {
  GDLGStream *a;
  bool isLog;
  DDouble axisrange; //to circumvent plplot passing a non-zero value instead of strict 0.0
  double nchars; //length of string *returned* after formatting. Can be non-integer.
  SizeT counter;
  bool reset; //reset internal counter each time a new 'axis' command is issued
  int what;
  SizeT nTickFormat;
  DDouble axismin;
  DDouble axismax;
  DStringGDL* TickFormat;
  SizeT nTickUnits;
  DStringGDL* TickUnits;
  EnvT *e;
};

namespace lib {

  using namespace std;

  // main plotting routine (all defined using the plotting_routine_call class)
  void plot(EnvT* e);
  void plot_io(EnvT* e);
  void plot_oo(EnvT* e);
  void plot_oi(EnvT* e);
  void oplot(EnvT* e);
  void plots(EnvT* e);
  void surface(EnvT* e);
  void shade_surf(EnvT* e);
  void contour(EnvT* e);
  void xyouts(EnvT* e);
  void axis(EnvT* e);
  void polyfill(EnvT* e);
  void tv_image(EnvT* e);
  void usersym(EnvT* e);
  void set_shading(EnvT* e);

  // other plotting routines
  void erase(EnvT* e);
  void tvlct(EnvT* e);
  void wshow(EnvT* e);
  void wdelete(EnvT* e);
  void wset(EnvT* e);
  void window(EnvT* e);
  void set_plot(EnvT* e);
  BaseGDL* get_screen_size(EnvT* e);
  void device(EnvT* e);
  void cursor(EnvT* e);
  void tvcrs(EnvT* e);
  void empty(EnvT* e);
  BaseGDL* format_axis_values(EnvT *e);
  void scale3_pro(EnvT* e);
  void t3d_pro(EnvT* e);

  BaseGDL* convert_coord(EnvT* e);

  // Map stuff
  void get_mapset(bool &mapset);
  void set_mapset(bool mapset);
#ifdef USE_LIBPROJ
  void GDLgrProjectedPolygonPlot(GDLGStream * a, PROJTYPE ref, DStructGDL* map, DDoubleGDL *lons, DDoubleGDL *lats, bool isRadians, bool const doFill, bool const doLines, DLongGDL *conn = NULL);
#endif
  //3D conversions
  void SelfTranspose3d(DDoubleGDL* me);
  void SelfReset3d(DDoubleGDL* me);
  void SelfTranslate3d(DDoubleGDL* me, DDouble *trans);
  void SelfScale3d(DDoubleGDL* me, DDouble *scale);
  void SelfRotate3d(DDoubleGDL* me, DDouble *rot);
  void SelfPerspective3d(DDoubleGDL* me, DDouble zdist);
  void SelfOblique3d(DDoubleGDL* me, DDouble dist, DDouble angle);
  void SelfExch3d(DDoubleGDL* me, T3DEXCHANGECODE axisExchangeCode);
  void SelfProjectXY(DDoubleGDL *x, DDoubleGDL *y);
  void SelfProjectXY(SizeT nEl, DDouble *x, DDouble *y, COORDSYS const coordinateSystem);
  void yzaxisExch(DDouble* me);
  void SelfConvertToNormXYZ(DDoubleGDL* x, bool &xLog, DDoubleGDL* y, bool &yLog, DDoubleGDL* z, bool &zLog, COORDSYS &code);
  void SelfConvertToNormXYZ(DDouble &x, bool const xLog, DDouble &y, bool const yLog, DDouble &z, bool const zLog, COORDSYS const code);
  void SelfConvertToNormXY(SizeT n, PLFLT *xt, bool const xLog, PLFLT *yt, bool const yLog, COORDSYS const code);
  void SelfConvertToNormXY(DDoubleGDL* x, bool &xLog, DDoubleGDL* y, bool &yLog, COORDSYS &code);
  void SelfPDotTTransformXYZ(SizeT n, PLFLT *xt, PLFLT *yt, PLFLT *zt);
  void SelfPDotTTransformXYZ(DDoubleGDL *xt, DDoubleGDL *yt, DDoubleGDL *zt);
  void PDotTTransformXYZval(PLFLT x, PLFLT y, PLFLT *xt, PLFLT *yt, PLPointer data);
  DDoubleGDL* gdlDefinePlplotRotationMatrix(DDouble az, DDouble alt, DDouble *scale, bool save);
  bool gdlInterpretT3DMatrixAsPlplotRotationMatrix(DDouble &az, DDouble &alt, DDouble &ay, DDouble *scale, T3DEXCHANGECODE &axisExchangeCode);
  DDoubleGDL* gdlGetT3DMatrix();
  void gdlStartT3DMatrixDriverTransform(GDLGStream *a, DDouble zValue);
  void gdlStartSpecial3DDriverTransform( GDLGStream *a, GDL_3DTRANSFORMDEVICE &PlotDevice3D);
  void gdlExchange3DDriverTransform( GDLGStream *a);
  void gdlSetZto3DDriverTransform( GDLGStream *a, DDouble zValue);
  void gdlStop3DDriverTransform(GDLGStream *a);
  bool T3Denabled();

  class plotting_routine_call {
    // ensure execution of child-class destructors
  public:

    virtual ~plotting_routine_call() {
    };

    // private fields
  private:
    SizeT _nParam;
  private:
    bool abort;
    //  private: bool isDB; //see below why commented.

    // common helper methods
  protected:

    inline SizeT nParam() {
      return _nParam;
    }

    // prototypes for methods defining various steps
  private:
    virtual bool handle_args(EnvT*) = 0; // return value = overplot
  private:
    virtual bool prepareDrawArea(EnvT*, GDLGStream*) = 0;
  private:
    virtual void applyGraphics(EnvT*, GDLGStream*) = 0;
  private:
    virtual void post_call(EnvT*, GDLGStream*) = 0;

    // all steps combined (virtual methods cannot be called from ctor)
  public:

    void call(EnvT* e, SizeT n_params_required) {
      // when !d.name == Null  we do nothing !
      DString name = (*static_cast<DStringGDL*> (SysVar::D()->GetTag(SysVar::D()->Desc()->TagIndex("NAME"), 0)))[0];
      if (name == "NULL") return;

      _nParam = e->NParam(n_params_required);

      abort = handle_args(e);
      if (abort) return;

      GDLGStream* actStream = GraphicsDevice::GetDevice()->GetStream();
      if (actStream == NULL) e->Throw("Unable to create window.");

      //ALL THE DoubleBuffering and Flush() code below introduces terrible slowness in remote X displays, as well as a lot of time lost
      //for displays on the same server. They are completely removed now.      
      //      //double buffering kills the logic and operation of XOR modes. Use HasSafeDoubleBuffering() that tests this feature.)
      //      isDB = actStream->HasSafeDoubleBuffering();
      //      if (isDB) actStream->SetDoubleBuffering();

      if (name == "X" || name == "MAC" || name == "WIN") actStream->updatePageInfo(); //since window size can change

      abort = prepareDrawArea(e, actStream);
      if (abort) return;

      applyGraphics(e, actStream);

      post_call(e, actStream);
      // IDEM: SLOW
      //      if (isDB) actStream->eop(); else actStream->flush();
      //      if (isDB) actStream->UnSetDoubleBuffering();

      //this is absolutely necessary for widgets as for windows. However the virtual Update function
      //i.e., calling  plstream::cmd(PLESC_EXPOSE, NULL) is very slow.
      // See how to overload it by a faster function such as in GDLXStream::Update() . 
      actStream->Update();
    }
  };
  void gdlDoRangeExtrema(DDoubleGDL *xVal, DDoubleGDL *yVal, DDouble &min, DDouble &max, DDouble xmin, DDouble xmax, bool doMinMax = false, DDouble minVal = 0, DDouble maxVal = 0);
  void draw_polyline(GDLGStream *a, DDoubleGDL *xVal, DDoubleGDL *yVal, DLong psym = 0, bool append = false, DLongGDL *color = NULL);
  void SelfNormLonLat(DDoubleGDL *lonlat);
  void SelfPDotTTransformProjectedPolygonTable(DDoubleGDL *lonlat);
  DDoubleGDL* GDLgrGetProjectPolygon(GDLGStream * a, PROJTYPE ref, DStructGDL* map, DDoubleGDL *lons, DDoubleGDL *lats, DDoubleGDL *zVal, bool isRadians, bool const doFill, bool const dolines, DLongGDL *&conn);
  void GDLgrPlotProjectedPolygon(GDLGStream * a, DDoubleGDL *lonlat, bool const doFill, DLongGDL *conn);
  void gdlSetGraphicsPenColorToBackground(GDLGStream *a);
  void gdlLineStyle(GDLGStream *a, DLong style);
  DFloat* gdlGetRegion();
  void gdlStoreXAxisParameters(GDLGStream* actStream, DDouble Start, DDouble End, bool log);
  void gdlStoreYAxisParameters(GDLGStream* actStream, DDouble Start, DDouble End, bool log);
  void gdlStoreZAxisParameters(GDLGStream* actStream, DDouble Start, DDouble End, bool log, DDouble zposStart, DDouble zposEnd);
  void gdlGetAxisType(int axisId, bool &log);
  void gdlGetCurrentAxisWindow(int axisId, DDouble &wStart, DDouble &wEnd);
  void gdlStoreAxisType(int axisId, bool type);
  //  void gdlGetCharSizes(GDLGStream *a, PLFLT &nsx, PLFLT &nsy, DDouble &wsx, DDouble &wsy, 
  //		       DDouble &dsx, DDouble &dsy, DDouble &lsx, DDouble &lsy); 
  void GetSFromPlotStructs(DDouble **sx, DDouble **sy, DDouble **sz = NULL);
  void GetWFromPlotStructs(DFloat **wx, DFloat **wy, DFloat **wz);
  void ConvertToNormXY(SizeT n, DDouble *x, bool const xLog, DDouble *y, bool const yLog, COORDSYS const code);
  void ConvertToNormZ(SizeT n, DDouble *z, bool const zLog, COORDSYS const code);
  void gdlStoreCLIP();
  void gdlGetCLIPXY(DDouble &xStart,  DDouble &yStart, DDouble &xEnd, DDouble &yEnd);
  void GetCurrentUserLimits(DDouble &xStart, DDouble &xEnd, DDouble &yStart, DDouble &yEnd); //2D
  void GetCurrentUserLimits(DDouble &xStart, DDouble &xEnd, DDouble &yStart, DDouble &yEnd, DDouble &zStart, DDouble &zEnd); //3D
  void gdlAdjustAxisRange(EnvT* e, int axisId, DDouble &val_min, DDouble &val_max, bool &log);
  PLFLT AutoTick(DDouble x);
  PLFLT AutoLogTick(DDouble min, DDouble max);
  void setIsoPort(GDLGStream* actStream, PLFLT x1, PLFLT x2, PLFLT y1, PLFLT y2, PLFLT aspect);
  void GetMinMaxVal(DDoubleGDL* val, double* minVal, double* maxVal);
  void GetMinMaxValuesForSubset(DDoubleGDL* val, DDouble &minVal, DDouble &maxVal, SizeT endElement);
  void UpdateSWPlotStructs(GDLGStream* actStream, DDouble xStart, DDouble xEnd, DDouble yStart,
    DDouble yEnd, bool xLog, bool yLog);
  DDoubleGDL* getLabelingValues(int axisId);
  void defineLabeling(GDLGStream *a, int axisId, void(*func)(PLINT axis, PLFLT value, char *label, PLINT length, PLPointer data), PLPointer data);
  void resetLabeling(GDLGStream *a, int axisId);
  void gdlSimpleAxisTickFunc(PLINT axis, PLFLT value, char *label, PLINT length, PLPointer data);
  void gdlSingleAxisTickNamedFunc(PLINT axis, PLFLT value, char *label, PLINT length, PLPointer data);
  void gdlMultiAxisTickFunc(PLINT axis, PLFLT value, char *label, PLINT length, PLPointer data);
  void doOurOwnFormat(PLINT axisNotUsed, PLFLT value, char *label, PLINT length, PLPointer data);
  void gdlHandleUnwantedLogAxisValue(DDouble &min, DDouble &max, bool log);
  //
  //--------------FOLLOWING ARE STATIC FUNCTIONS-----------------------------------------------
  //This because static pointers to options indexes are needed to speed up process, but these indexes vary between
  //the definition of the caller functions (e.g. "CHARSIZE" is 1 for CONTOUR but 7 for XYOUTS). So they need to be kept
  //static (for speed) but private for each graphic command.

  static void gdlSetGraphicsBackgroundColorFromKw(EnvT *e, GDLGStream *a, bool kw = true) {
    DStructGDL* pStruct = SysVar::P(); //MUST NOT BE STATIC, due to .reset 
    DLong background =
      (*static_cast<DLongGDL*>
      (pStruct->GetTag(pStruct->Desc()->TagIndex("BACKGROUND"), 0)))[0];
    if (kw) {
      int BACKGROUNDIx = e->KeywordIx("BACKGROUND");
      e->AssureLongScalarKWIfPresent(BACKGROUNDIx, background);
    }
    DLong decomposed = GraphicsDevice::GetDevice()->GetDecomposed();
    a->Background(background, decomposed);
  }
  
  static void gdlSetGraphicsForegroundColorFromBackgroundKw(EnvT *e, GDLGStream *a, bool kw = true) {
    DStructGDL* pStruct = SysVar::P(); //MUST NOT BE STATIC, due to .reset 
    DLong background =
      (*static_cast<DLongGDL*>
      (pStruct->GetTag(pStruct->Desc()->TagIndex("BACKGROUND"), 0)))[0];
    if (kw) {
      int BACKGROUNDIx = e->KeywordIx("BACKGROUND");
      e->AssureLongScalarKWIfPresent(BACKGROUNDIx, background);
    }
    DLong decomposed = GraphicsDevice::GetDevice()->GetDecomposed();
    a->Color(background, decomposed);
  }
  
  static void gdlSetGraphicsForegroundColorFromKw(EnvT *e, GDLGStream *a, string OtherColorKw = "") {
    // Get COLOR from PLOT system variable
    DStructGDL* pStruct = SysVar::P(); //MUST NOT BE STATIC, due to .reset 
    DLong color =
      (*static_cast<DLongGDL*>
      (pStruct->GetTag(pStruct->Desc()->TagIndex("COLOR"), 0)))[0];

    DLongGDL *colorVect;
    int colorIx = e->KeywordIx("COLOR");
    int realcolorIx = colorIx;
    //eventually do not get color from standard "COLOR" keyword but from another...
    if (OtherColorKw != "") realcolorIx = e->KeywordIx(OtherColorKw);
    if (e->GetDefinedKW(realcolorIx) != NULL) {
      colorVect = e->GetKWAs<DLongGDL>(realcolorIx); //color can be vectorial, but...
      color = (*colorVect)[0]; //this function only sets color to 1st arg in list!
    }
    // Get decomposed value for colors
    DLong decomposed = GraphicsDevice::GetDevice()->GetDecomposed();
    a->Color(color, decomposed);
  }

  static void gdlGetPsym(EnvT *e, DLong &psym) {
    DStructGDL* pStruct = SysVar::P(); //MUST NOT BE STATIC, due to .reset 
    psym = (*static_cast<DLongGDL*>
      (pStruct->GetTag(pStruct->Desc()->TagIndex("PSYM"), 0)))[0];
    int PSYMIx = e->KeywordIx("PSYM");
    e->AssureLongScalarKWIfPresent(PSYMIx, psym);
    if (psym > 10 || psym < -8 || psym == 9)
      e->Throw(
      "PSYM (plotting symbol) out of range.");
  }

  static void gdlSetSymsize(EnvT *e, GDLGStream *a) {
    DStructGDL* pStruct = SysVar::P(); //MUST NOT BE STATIC, due to .reset 
    DFloat symsize = (*static_cast<DFloatGDL*>
      (pStruct->GetTag(pStruct->Desc()->TagIndex("SYMSIZE"), 0)))[0];
    //NOTE THAT AS OF IDL 8.2 !P.SYMSIZE, HOWEVER EXISTING, IS NOT TAKEN INTO ACCOUNT. We however do not want
    //to reproduce this feature.
    int SYMSIZEIx = e->KeywordIx("SYMSIZE");
    e->AssureFloatScalarKWIfPresent(SYMSIZEIx, symsize);
    if (symsize <= 0.0) symsize = 1.0;
    a->setSymbolSize(symsize);
  }
  //  static void GetUserSymSize(EnvT *e, GDLGStream *a, DDouble& UsymConvX, DDouble& UsymConvY)
  //  {
  //    //get symsize
  //    DStructGDL* pStruct=SysVar::P();   //MUST NOT BE STATIC, due to .reset 
  //    DFloat symsize=(*static_cast<DFloatGDL*>
  //                    (pStruct->GetTag(pStruct->Desc()->TagIndex("SYMSIZE"), 0)))[0];
  //    int SYMSIZEIx = e->KeywordIx("SYMSIZE");
  //    e->AssureFloatScalarKWIfPresent(SYMSIZEIx, symsize);
  //    if ( symsize<=0.0 ) symsize=1.0;
  //    
  //    UsymConvX=(0.5*symsize*(a->wCharLength()/a->charScale())); //be dependent only on symsize!
  //    UsymConvY=(0.5*symsize*(a->wCharHeight()/a->charScale()));
  //    PLFLT wun, wdeux, wtrois, wquatre; //take care of axes world orientation!
  //    a->pageWorldCoordinates(wun, wdeux, wtrois, wquatre);
  //    if ((wdeux-wun)<0) UsymConvX*=-1.0;
  //    if ((wquatre-wtrois)<0) UsymConvY*=-1.0;
  //    if (GDL_DEBUG_PLSTREAM) fprintf(stderr,"GetUserSymSize(%f,%f), charlen=%f, charheight=%f, charscale=%f\n",
  //				    UsymConvX, UsymConvY,a->wCharLength(),a->wCharHeight(),a->charScale());
  //  }

  static void gdlSetPlotCharsize(EnvT *e, GDLGStream *a, bool accept_sizeKw = false) {
    PLFLT charsize;
    DDouble pmultiscale = 1.0;
    // get !P preference or !FANCY ... they should agree as charsize = 0.2*FANCY+0.8 
    DStructGDL* pStruct = SysVar::P(); //MUST NOT BE STATIC, due to .reset
    DFloat* charsizePos = &((*static_cast<DFloatGDL*> (pStruct->GetTag(pStruct->Desc()->TagIndex("CHARSIZE"), 0)))[0]);
    charsize = charsizePos[0];
    //    //if charsize==0 see if !FANCY is set to something above 1 or below 1
    //    DIntGDL* fancy= SysVar::GetFancy();
    //    if ((*fancy)[0] > -4) { //negative values are a mess
    //     PLFLT fancySize = 0.2 * (*fancy)[0] + 0.8;
    //     if (fancySize != charsize) { //make them agree
    //      charsize = fancySize;
    //      charsizePos[0] = charsize;
    //     }
    //    }
    //overload with command preference. Charsize may be a vector now in some gdl commands, take care of it:
    if (accept_sizeKw) //XYOUTS specials!
    {
      int SIZEIx = e->KeywordIx("SIZE"); //define here only (else trig an assert() )
      DFloat fcharsize;
      fcharsize = charsize;
      e->AssureFloatScalarKWIfPresent(SIZEIx, fcharsize);
      charsize = fcharsize;
    }
    int charsizeIx = e->KeywordIx("CHARSIZE");
    if (e->GetDefinedKW(charsizeIx) != NULL) {
      DFloatGDL* charsizeVect = e->GetKWAs<DFloatGDL>(charsizeIx);
      charsize = (*charsizeVect)[0];
    }
    if (charsize <= 0.0) charsize = 1.0;
    // adjust if MULTI:
    DLongGDL* pMulti = SysVar::GetPMulti();
    if ((*pMulti)[1] > 2 || (*pMulti)[2] > 2) pmultiscale = 0.5;
    a->sizeChar(charsize * pmultiscale);
  }

  static void gdlSetPlotCharthick(EnvT *e, GDLGStream *a) {
    // get !P preference
    DStructGDL* pStruct = SysVar::P(); //MUST NOT BE STATIC, due to .reset 
    DFloat charthick = (*static_cast<DFloatGDL*>
      (pStruct->GetTag
      (pStruct->Desc()->TagIndex("CHARTHICK"), 0)))[0];
    int charthickIx = e->KeywordIx("CHARTHICK"); //Charthick values may be vector in GDL, not in IDL!
    if (e->GetDefinedKW(charthickIx) != NULL) {
      DFloatGDL* charthickVect = e->GetKWAs<DFloatGDL>(charthickIx);
      charthick = (*charthickVect)[0];
    }
    if (charthick <= 0.0) charthick = 1.0;
    a->Thick(charthick);
  }

  static PLFLT gdlComputeTickInterval(EnvT *e, int axisId, DDouble &min, DDouble &max, bool log) {
    DLong nticks = 0;

    int XTICKSIx = e->KeywordIx("XTICKS");
    int YTICKSIx = e->KeywordIx("YTICKS");
    int ZTICKSIx = e->KeywordIx("ZTICKS");
    int choosenIx = XTICKSIx;
    DStructGDL* Struct = NULL;
    if (axisId == XAXIS) {
      Struct = SysVar::X();
      choosenIx = XTICKSIx;
    }
    if (axisId == YAXIS) {
      Struct = SysVar::Y();
      choosenIx = YTICKSIx;
    }
    if (axisId == ZAXIS) {
      Struct = SysVar::Z();
      choosenIx = ZTICKSIx;
    }

    if (Struct != NULL) {
      unsigned tickTag = Struct->Desc()->TagIndex("TICKS");
      nticks = (*static_cast<DLongGDL*> (Struct->GetTag(tickTag, 0)))[0];
    }
    e->AssureLongScalarKWIfPresent(choosenIx, nticks);

    PLFLT intv;
    if (nticks == 0) {
      intv = (log) ? AutoLogTick(min, max) : AutoTick(max - min);
    } else {
      intv = (log) ? log10(max - min) / nticks : (max - min) / nticks;
    }
    return intv;
  }

  static void gdlGetDesiredAxisCharsize(EnvT* e, int axisId, DFloat &charsize) {
    //default:
    charsize = 1.0;
    // get !P preference. Even if [xyz]charsize is absent, presence of charsize or !P.charsize must be taken into account.
    DStructGDL* pStruct = SysVar::P(); //MUST NOT BE STATIC, due to .reset 
    charsize = (*static_cast<DFloatGDL*>
      (pStruct->GetTag
      (pStruct->Desc()->TagIndex("CHARSIZE"), 0)))[0];
    int CharsizeIx = e->KeywordIx("CHARSIZE");
    //cerr<<" CHARSIZE: "<< CharsizeIx<<" ("<< &CharsizeIx<<")"<<endl;
    e->AssureFloatScalarKWIfPresent(CharsizeIx, charsize); // option charsize overloads P.CHARSIZE
    if (charsize == 0) charsize = 1.0;
    // Axis Preference. Is a Multiplier!
    int XCharsizeIx = e->KeywordIx("XCHARSIZE");
    int YCharsizeIx = e->KeywordIx("YCHARSIZE");
    int ZCharsizeIx = e->KeywordIx("ZCHARSIZE");
    int choosenIx = XCharsizeIx;
    DStructGDL* Struct = NULL;
    if (axisId == XAXIS) {
      Struct = SysVar::X();
      choosenIx = XCharsizeIx;
    }
    if (axisId == YAXIS) {
      Struct = SysVar::Y();
      choosenIx = YCharsizeIx;
    }
    if (axisId == ZAXIS) {
      Struct = SysVar::Z();
      choosenIx = ZCharsizeIx;
    }

    if (Struct != NULL) {
      unsigned charsizeTag = Struct->Desc()->TagIndex("CHARSIZE"); //[XYZ].CHARSIZE
      DFloat axisCharsizeMultiplier = (*static_cast<DFloatGDL*> (Struct->GetTag(charsizeTag, 0)))[0];
      e->AssureFloatScalarKWIfPresent(choosenIx, axisCharsizeMultiplier); //option [XYZ]CHARSIZE overloads ![XYZ].CHARSIZE
      if (axisCharsizeMultiplier > 0.0) charsize *= axisCharsizeMultiplier; //IDL Behaviour...
    }
  }

  static void gdlSetAxisCharsize(EnvT *e, GDLGStream *a, int axisId) {

    DFloat charsize = 0.0;
    DDouble pmultiscale = 1.0;
    gdlGetDesiredAxisCharsize(e, axisId, charsize);
    // adjust if MULTI:
    DLongGDL* pMulti = SysVar::GetPMulti();
    if ((*pMulti)[1] > 2 || (*pMulti)[2] > 2) pmultiscale = 0.5; //IDL behaviour
    // scale default value (which depends on number of subpages)
    // a->schr(0.0, charsize*pmultiscale);
    a->sizeChar(charsize * pmultiscale);
  }

  static void gdlGetDesiredAxisGridStyle(EnvT* e, int axisId, DLong &axisGridstyle) {
    axisGridstyle = 0;
    DStructGDL* Struct = NULL;
    int XGRIDSTYLEIx = e->KeywordIx("XGRIDSTYLE");
    int YGRIDSTYLEIx = e->KeywordIx("YGRIDSTYLE");
    int ZGRIDSTYLEIx = e->KeywordIx("ZGRIDSTYLE");
    int choosenIx = XGRIDSTYLEIx;
    if (axisId == XAXIS) {
      Struct = SysVar::X();
      choosenIx = XGRIDSTYLEIx;
    }
    if (axisId == YAXIS) {
      Struct = SysVar::Y();
      choosenIx = YGRIDSTYLEIx;
    }
    if (axisId == ZAXIS) {
      Struct = SysVar::Z();
      choosenIx = ZGRIDSTYLEIx;
    }

    if (Struct != NULL) {
      unsigned gridstyleTag = Struct->Desc()->TagIndex("GRIDSTYLE");
      axisGridstyle = (*static_cast<DLongGDL*> (Struct->GetTag(gridstyleTag, 0)))[0];
      e->AssureLongScalarKWIfPresent(choosenIx, axisGridstyle);
    }
  }

  static void gdlGetDesiredAxisMargin(EnvT *e, int axisId, DFloat &start, DFloat &end) {
    int XMARGINIx = e->KeywordIx("XMARGIN");
    int YMARGINIx = e->KeywordIx("YMARGIN");
    int ZMARGINIx = e->KeywordIx("ZMARGIN");
    int choosenIx = XMARGINIx;
    DStructGDL* Struct = NULL;
    if (axisId == XAXIS) {
      Struct = SysVar::X();
      choosenIx = XMARGINIx;
    }
    if (axisId == YAXIS) {
      Struct = SysVar::Y();
      choosenIx = YMARGINIx;
    }
    if (axisId == ZAXIS) {
      Struct = SysVar::Z();
      choosenIx = ZMARGINIx;
    }

    if (Struct != NULL) {
      unsigned marginTag = Struct->Desc()->TagIndex("MARGIN");
      start = (*static_cast<DFloatGDL*> (Struct->GetTag(marginTag, 0)))[0];
      end = (*static_cast<DFloatGDL*> (Struct->GetTag(marginTag, 0)))[1];
    }

    BaseGDL* Margin = e->GetKW(choosenIx);
    if (Margin != NULL) {
      if (Margin->N_Elements() > 2)
        e->Throw("Keyword array parameter " + axisName[axisId] + "MARGIN must have from 1 to 2 elements.");
      Guard<DFloatGDL> guard;
      DFloatGDL* MarginF = static_cast<DFloatGDL*>
        (Margin->Convert2(GDL_FLOAT, BaseGDL::COPY));
      guard.Reset(MarginF);
      start = (*MarginF)[0];
      if (MarginF->N_Elements() > 1)
        end = (*MarginF)[1];
    }
  }

  static void gdlGetDesiredAxisMinor(EnvT* e, int axisId, DLong &axisMinor) {
    axisMinor = 0;
    int XMINORIx = e->KeywordIx("XMINOR");
    int YMINORIx = e->KeywordIx("YMINOR");
    int ZMINORIx = e->KeywordIx("ZMINOR");
    int choosenIx = XMINORIx;
    DStructGDL* Struct = NULL;
    if (axisId == XAXIS) {
      Struct = SysVar::X();
      choosenIx = XMINORIx;
    }
    if (axisId == YAXIS) {
      Struct = SysVar::Y();
      choosenIx = YMINORIx;
    }
    if (axisId == ZAXIS) {
      Struct = SysVar::Z();
      choosenIx = ZMINORIx;
    }
    if (Struct != NULL) {
      unsigned AxisMinorTag = Struct->Desc()->TagIndex("MINOR");
      axisMinor = (*static_cast<DLongGDL*> (Struct->GetTag(AxisMinorTag, 0)))[0];
    }
    e->AssureLongScalarKWIfPresent(choosenIx, axisMinor);
  }

  static bool gdlGetDesiredAxisRange(EnvT *e, int axisId, DDouble &start, DDouble &end) {
    bool set = false;
    int XRANGEIx = e->KeywordIx("XRANGE");
    int YRANGEIx = e->KeywordIx("YRANGE");
    int ZRANGEIx = e->KeywordIx("ZRANGE");
    int choosenIx = XRANGEIx;
    DStructGDL* Struct = NULL;
    if (axisId == XAXIS) {
      Struct = SysVar::X();
      choosenIx = XRANGEIx;
    }
    if (axisId == YAXIS) {
      Struct = SysVar::Y();
      choosenIx = YRANGEIx;
    }
    if (axisId == ZAXIS) {
      Struct = SysVar::Z();
      choosenIx = ZRANGEIx;
    }
    if (Struct != NULL) {
      DDouble test1, test2;
      unsigned rangeTag = Struct->Desc()->TagIndex("RANGE");
      test1 = (*static_cast<DDoubleGDL*> (Struct->GetTag(rangeTag, 0)))[0];
      test2 = (*static_cast<DDoubleGDL*> (Struct->GetTag(rangeTag, 0)))[1];
      if (!((test1 - test2) == 0.0)) {
        start = test1;
        end = test2;
        set = true;
      }
    }
    BaseGDL* Range = e->GetDefinedKW(choosenIx);
    if (Range != NULL) {
      if (Range->N_Elements() != 2)
        e->Throw("Keyword array parameter " + axisName[axisId] + "RANGE must have 2 elements.");
      Guard<DDoubleGDL> guard;
      DDoubleGDL* RangeF = static_cast<DDoubleGDL*> (Range->Convert2(GDL_DOUBLE, BaseGDL::COPY));
      guard.Reset(RangeF);
      if (!(((*RangeF)[0]-(*RangeF)[1]) == 0.0)) {
        start = (*RangeF)[0];
        end = (*RangeF)[1];
        set = true;
      }
    }
    return set;
  }

  static void gdlGetDesiredAxisStyle(EnvT *e, int axisId, DLong &style) {
    int XSTYLEIx = e->KeywordIx("XSTYLE");
    int YSTYLEIx = e->KeywordIx("YSTYLE");
    int ZSTYLEIx = e->KeywordIx("ZSTYLE");
    int choosenIx = XSTYLEIx;
    DStructGDL* Struct = NULL;
    if (axisId == XAXIS) {
      Struct = SysVar::X();
      choosenIx = XSTYLEIx;
    }
    if (axisId == YAXIS) {
      Struct = SysVar::Y();
      choosenIx = YSTYLEIx;
    }
    if (axisId == ZAXIS) {
      Struct = SysVar::Z();
      choosenIx = ZSTYLEIx;
    }

    if (Struct != NULL) {
      int styleTag = Struct->Desc()->TagIndex("STYLE");
      style = (*static_cast<DLongGDL*> (Struct->GetTag(styleTag, 0)))[0];
    }

    e->AssureLongScalarKWIfPresent(choosenIx, style);
  }

  static void gdlGetDesiredAxisThick(EnvT *e, int axisId, DFloat &thick) {
    thick = 1.0;
    int XTHICKIx = e->KeywordIx("XTHICK");
    int YTHICKIx = e->KeywordIx("YTHICK");
    int ZTHICKIx = e->KeywordIx("ZTHICK");
    int choosenIx = XTHICKIx;
    DStructGDL* Struct = NULL;
    if (axisId == XAXIS) {
      Struct = SysVar::X();
      choosenIx = XTHICKIx;
    }
    if (axisId == YAXIS) {
      Struct = SysVar::Y();
      choosenIx = YTHICKIx;
    }
    if (axisId == ZAXIS) {
      Struct = SysVar::Z();
      choosenIx = ZTHICKIx;
    }

    if (Struct != NULL) {
      //not static!
      int thickTag = Struct->Desc()->TagIndex("THICK");
      thick = (*static_cast<DFloatGDL*> (Struct->GetTag(thickTag, 0)))[0];
    }
    e->AssureFloatScalarKWIfPresent(choosenIx, thick);
    if (thick <= 0.0) thick = 1.0;
  }

  static void gdlGetDesiredAxisTickget(EnvT *e, int axisId, DDoubleGDL *Axistickget) {
    //TODO!
  }

  static void gdlGetDesiredAxisTickFormat(EnvT* e, int axisId, DStringGDL* &axisTickformatVect) {
    int XTICKFORMATIx = e->KeywordIx("XTICKFORMAT");
    int YTICKFORMATIx = e->KeywordIx("YTICKFORMAT");
    int ZTICKFORMATIx = e->KeywordIx("ZTICKFORMAT");
    int choosenIx = XTICKFORMATIx;
    DStructGDL* Struct = NULL;
    if (axisId == XAXIS) {
      Struct = SysVar::X();
      choosenIx = XTICKFORMATIx;
    }
    if (axisId == YAXIS) {
      Struct = SysVar::Y();
      choosenIx = YTICKFORMATIx;
    }
    if (axisId == ZAXIS) {
      Struct = SysVar::Z();
      choosenIx = ZTICKFORMATIx;
    }

    if (Struct != NULL) {
      unsigned AxisTickformatTag = Struct->Desc()->TagIndex("TICKFORMAT");
      axisTickformatVect = static_cast<DStringGDL*> (Struct->GetTag(AxisTickformatTag, 0));
    }
    if (e->GetDefinedKW(choosenIx) != NULL) {
      axisTickformatVect = e->GetKWAs<DStringGDL>(choosenIx);
    }
  }

  static void gdlGetDesiredAxisTickInterval(EnvT* e, int axisId, DDouble &axisTickinterval) {
    axisTickinterval = 0;
    int XTICKINTERVALIx = e->KeywordIx("XTICKINTERVAL");
    int YTICKINTERVALIx = e->KeywordIx("YTICKINTERVAL");
    int ZTICKINTERVALIx = e->KeywordIx("ZTICKINTERVAL");
    int choosenIx = XTICKINTERVALIx;
    DStructGDL* Struct = NULL;
    if (axisId == XAXIS) {
      Struct = SysVar::X();
      choosenIx = XTICKINTERVALIx;
    }
    if (axisId == YAXIS) {
      Struct = SysVar::Y();
      choosenIx = YTICKINTERVALIx;
    }
    if (axisId == ZAXIS) {
      Struct = SysVar::Z();
      choosenIx = ZTICKINTERVALIx;
    }

    if (Struct != NULL) {
      axisTickinterval = (*static_cast<DDoubleGDL*>
        (Struct->GetTag
        (Struct->Desc()->TagIndex("TICKINTERVAL"), 0)))[0];
    }
    e->AssureDoubleScalarKWIfPresent(choosenIx, axisTickinterval);
    if (axisTickinterval < 0) axisTickinterval=0;
  }

  static void gdlGetDesiredAxisTickLayout(EnvT* e, int axisId, DLong &axisTicklayout) {
    axisTicklayout = 0;
    int XTICKLAYOUTIx = e->KeywordIx("XTICKLAYOUT");
    int YTICKLAYOUTIx = e->KeywordIx("YTICKLAYOUT");
    int ZTICKLAYOUTIx = e->KeywordIx("ZTICKLAYOUT");
    int choosenIx = XTICKLAYOUTIx;
    DStructGDL* Struct = NULL;
    if (axisId == XAXIS) {
      Struct = SysVar::X();
      choosenIx = XTICKLAYOUTIx;
    }
    if (axisId == YAXIS) {
      Struct = SysVar::Y();
      choosenIx = YTICKLAYOUTIx;
    }
    if (axisId == ZAXIS) {
      Struct = SysVar::Z();
      choosenIx = ZTICKLAYOUTIx;
    }
    if (Struct != NULL) {
      axisTicklayout = (*static_cast<DLongGDL*>
        (Struct->GetTag
        (Struct->Desc()->TagIndex("TICKLAYOUT"), 0)))[0];
    }
    e->AssureLongScalarKWIfPresent(choosenIx, axisTicklayout);
  }

  static void gdlGetDesiredAxisTickLen(EnvT* e, int axisId, DFloat &ticklen) {
    // order: !P.TICKLEN, TICKLEN, !X.TICKLEN, /XTICKLEN
    // get !P preference
    DStructGDL* pStruct = SysVar::P(); //MUST NOT BE STATIC, due to .reset 
    ticklen = (*static_cast<DFloatGDL*>
      (pStruct->GetTag
      (pStruct->Desc()->TagIndex("TICKLEN"), 0)))[0]; //!P.TICKLEN, always exist, may be 0
    int TICKLENIx = e->KeywordIx("TICKLEN");
    e->AssureFloatScalarKWIfPresent(TICKLENIx, ticklen); //overwritten by TICKLEN option

    int XTICKLENIx = e->KeywordIx("XTICKLEN");
    int YTICKLENIx = e->KeywordIx("YTICKLEN");
    int ZTICKLENIx = e->KeywordIx("ZTICKLEN");
    int choosenIx = XTICKLENIx;
    DStructGDL* Struct = NULL;
    if (axisId == XAXIS) {
      Struct = SysVar::X();
      choosenIx = XTICKLENIx;
    }
    if (axisId == YAXIS) {
      Struct = SysVar::Y();
      choosenIx = YTICKLENIx;
    }
    if (axisId == ZAXIS) {
      Struct = SysVar::Z();
      choosenIx = ZTICKLENIx;
    }
    if (Struct != NULL) {
      unsigned ticklenTag = Struct->Desc()->TagIndex("TICKLEN");
      DFloat axisTicklen = (*static_cast<DFloatGDL*> (Struct->GetTag(ticklenTag, 0)))[0]; //![XYZ].TICKLEN (exist)
      e->AssureFloatScalarKWIfPresent(choosenIx, axisTicklen); //overriden by kw
      if (axisTicklen != 0.0) ticklen = axisTicklen;
    }
  }

  static void gdlGetDesiredAxisTickName(EnvT* e, GDLGStream* a, int axisId, DStringGDL* &axisTicknameVect) {

    int XTICKNAMEIx = e->KeywordIx("XTICKNAME");
    int YTICKNAMEIx = e->KeywordIx("YTICKNAME");
    int ZTICKNAMEIx = e->KeywordIx("ZTICKNAME");
    int choosenIx = XTICKNAMEIx;
    DStructGDL* Struct = NULL;
    if (axisId == XAXIS) {
      Struct = SysVar::X();
      choosenIx = XTICKNAMEIx;
    }
    if (axisId == YAXIS) {
      Struct = SysVar::Y();
      choosenIx = YTICKNAMEIx;
    }
    if (axisId == ZAXIS) {
      Struct = SysVar::Z();
      choosenIx = ZTICKNAMEIx;
    }
    if (Struct != NULL) {
      unsigned AxisTicknameTag = Struct->Desc()->TagIndex("TICKNAME");
      axisTicknameVect = static_cast<DStringGDL*> (Struct->GetTag(AxisTicknameTag, 0));
    }
    if (e->GetDefinedKW(choosenIx) != NULL) {
      axisTicknameVect = e->GetKWAs<DStringGDL>(choosenIx);
      //translate format codes here:
      //      for (SizeT iname=0; iname < axisTicknameVect->N_Elements(); ++iname) {
      //        std::string out = std::string("");
      //        a->TranslateFormatCodes(((*axisTicknameVect)[iname]).c_str(),out);
      ////TBD: not finished, see cases not treated in TransmateFormatCodes (gdlgstream.cpp)
      //        (*axisTicknameVect)[iname]=out;
      //      }
    }

  }

  static void gdlGetDesiredAxisTicks(EnvT* e, int axisId, DLong &axisTicks) {
    axisTicks = 0;

    int XTICKSIx = e->KeywordIx("XTICKS");
    int YTICKSIx = e->KeywordIx("YTICKS");
    int ZTICKSIx = e->KeywordIx("ZTICKS");
    int choosenIx = XTICKSIx;
    DStructGDL* Struct = NULL;
    if (axisId == XAXIS) {
      Struct = SysVar::X();
      choosenIx = XTICKSIx;
    }
    if (axisId == YAXIS) {
      Struct = SysVar::Y();
      choosenIx = YTICKSIx;
    }
    if (axisId == ZAXIS) {
      Struct = SysVar::Z();
      choosenIx = ZTICKSIx;
    }

    if (Struct != NULL) {
      axisTicks = (*static_cast<DLongGDL*>
        (Struct->GetTag
        (Struct->Desc()->TagIndex("TICKS"), 0)))[0];
    }
    e->AssureLongScalarKWIfPresent(choosenIx, axisTicks);
    if (axisTicks > 59) e->Throw("Value of number of ticks is out of allowed range.");
  }


  //if axis tick units is specified, first tickunit determines how the automatic limits are computed.
  // for example, if tickunits=['year','day'] the limits will be on a round nuber of years.
  // This is conveyed by the code

  static int gdlGetCalendarCode(EnvT* e, int axisId) {
    int XTICKUNITSIx = e->KeywordIx("XTICKUNITS");
    int YTICKUNITSIx = e->KeywordIx("YTICKUNITS");
    int ZTICKUNITSIx = e->KeywordIx("ZTICKUNITS");
    int choosenIx = XTICKUNITSIx;
    DStructGDL* Struct = NULL;
    if (axisId == XAXIS) {
      Struct = SysVar::X();
      choosenIx = XTICKUNITSIx;
    }
    if (axisId == YAXIS) {
      Struct = SysVar::Y();
      choosenIx = YTICKUNITSIx;
    }
    if (axisId == ZAXIS) {
      Struct = SysVar::Z();
      choosenIx = ZTICKUNITSIx;
    }
    DStringGDL* axisTickunitsVect = NULL;
    if (Struct != NULL) {
      unsigned AxisTickunitsTag = Struct->Desc()->TagIndex("TICKUNITS");
      axisTickunitsVect = static_cast<DStringGDL*> (Struct->GetTag(AxisTickunitsTag, 0));
    }
    if (e->GetDefinedKW(choosenIx) != NULL) {
      axisTickunitsVect = e->GetKWAs<DStringGDL>(choosenIx);
    }
    int code = 0;
    DString what = StrUpCase((*axisTickunitsVect)[0]);
    if (what.substr(0, 4) == "YEAR") code = 1;
    else if (what.substr(0, 5) == "MONTH") code = 2;
    else if (what.substr(0, 3) == "DAY") code = 3;
    else if (what.substr(0, 7) == "NUMERIC") code = 3;
    else if (what.substr(0, 4) == "HOUR") code = 4;
    else if (what.substr(0, 6) == "MINUTE") code = 5;
    else if (what.substr(0, 6) == "SECOND") code = 6;
    else if (what.substr(0, 4) == "TIME") code = 7;
    return code;
  }

  static void gdlGetDesiredAxisTickUnits(EnvT* e, int axisId, DStringGDL* &axisTickunitsVect) {
    int XTICKUNITSIx = e->KeywordIx("XTICKUNITS");
    int YTICKUNITSIx = e->KeywordIx("YTICKUNITS");
    int ZTICKUNITSIx = e->KeywordIx("ZTICKUNITS");
    int choosenIx = XTICKUNITSIx;
    DStructGDL* Struct = NULL;
    if (axisId == XAXIS) {
      Struct = SysVar::X();
      choosenIx = XTICKUNITSIx;
    }
    if (axisId == YAXIS) {
      Struct = SysVar::Y();
      choosenIx = YTICKUNITSIx;
    }
    if (axisId == ZAXIS) {
      Struct = SysVar::Z();
      choosenIx = ZTICKUNITSIx;
    }
    if (Struct != NULL) {
      unsigned AxisTickunitsTag = Struct->Desc()->TagIndex("TICKUNITS");
      axisTickunitsVect = static_cast<DStringGDL*> (Struct->GetTag(AxisTickunitsTag, 0));
    }
    if (e->GetDefinedKW(choosenIx) != NULL) {
      axisTickunitsVect = e->GetKWAs<DStringGDL>(choosenIx);
    }
  }
  static bool gdlHasTickUnits(EnvT* e, int axisId) {
    bool has = false;
    int XTICKUNITSIx = e->KeywordIx("XTICKUNITS");
    int YTICKUNITSIx = e->KeywordIx("YTICKUNITS");
    int ZTICKUNITSIx = e->KeywordIx("ZTICKUNITS");
    int choosenIx = XTICKUNITSIx;
    DStructGDL* Struct = NULL;
    if (axisId == XAXIS) {
      Struct = SysVar::X();
      choosenIx = XTICKUNITSIx;
    }
    if (axisId == YAXIS) {
      Struct = SysVar::Y();
      choosenIx = YTICKUNITSIx;
    }
    if (axisId == ZAXIS) {
      Struct = SysVar::Z();
      choosenIx = ZTICKUNITSIx;
    }
    if (Struct != NULL) {
      unsigned AxisTickunitsTag = Struct->Desc()->TagIndex("TICKUNITS");
      DStringGDL* axisTickunitsVect = static_cast<DStringGDL*> (Struct->GetTag(AxisTickunitsTag, 0));
      for (auto i = 0; i < axisTickunitsVect->N_Elements(); ++i) {
        if ((*axisTickunitsVect)[i].size() > 0) {
          has = true;
          break;
        }
      }
    }
    if (e->GetDefinedKW(choosenIx) != NULL) {
      DStringGDL* axisTickunitsVect = e->GetKWAs<DStringGDL>(choosenIx);
      for (auto i = 0; i < axisTickunitsVect->N_Elements(); ++i) {
        if ((*axisTickunitsVect)[i].size() > 0) {
          has = true;
          break;
        }
      }
    }
    return has;
  }

  static bool gdlGetDesiredAxisTickv(EnvT* e, int axisId, DDoubleGDL* axisTickvVect) {
    bool exist = false;
    int XTICKVIx = e->KeywordIx("XTICKV");
    int YTICKVIx = e->KeywordIx("YTICKV");
    int ZTICKVIx = e->KeywordIx("ZTICKV");
    int choosenIx = XTICKVIx;
    DStructGDL* Struct = NULL;
    if (axisId == XAXIS) {
      Struct = SysVar::X();
      choosenIx = XTICKVIx;
    }
    if (axisId == YAXIS) {
      Struct = SysVar::Y();
      choosenIx = YTICKVIx;
    }
    if (axisId == ZAXIS) {
      Struct = SysVar::Z();
      choosenIx = ZTICKVIx;
    }
    if (Struct != NULL) {
      unsigned AxisTickvTag = Struct->Desc()->TagIndex("TICKV");
      axisTickvVect = static_cast<DDoubleGDL*> (Struct->GetTag(AxisTickvTag, 0));
      exist = true;
    }
    if (e->GetDefinedKW(choosenIx) != NULL) {
      axisTickvVect = e->GetKWAs<DDoubleGDL>(choosenIx);
      exist = true;
    }
    if (exist) { //there is something
      exist = false; //but it could be all Zeros...
      for (auto i = 0; i < axisTickvVect->N_Elements(); ++i) if ((*axisTickvVect)[i] != 0) {
          exist = true;
          break;
        }
    }
    return exist;
  }

  //if [X|Y|Z]TICK_GET was given for axis, write the values.

  static void gdlWriteDesiredAxisTickGet(EnvT* e, int axisId, bool isLog) {
    int XTICKGIx = e->KeywordIx("XTICK_GET");
    int YTICKGIx = e->KeywordIx("YTICK_GET");
    int ZTICKGIx = e->KeywordIx("ZTICK_GET");
    int choosenIx = XTICKGIx;
    if (axisId == XAXIS) {
      choosenIx = XTICKGIx;
    }
    if (axisId == YAXIS) {
      choosenIx = YTICKGIx;
    }
    if (axisId == ZAXIS) {
      choosenIx = ZTICKGIx;
    }
    if (e->WriteableKeywordPresent(choosenIx)) {
      DDoubleGDL* val = getLabelingValues(axisId);
      if (val == NULL) e->Throw("Internal GDL error for [X|Y|Z]TICK_GET, please report");
      if (isLog) for (auto i = 0; i < val->N_Elements(); ++i) (*val)[i] = pow(10.0, (*val)[i]);
      e->SetKW(choosenIx, val);
    }
  }

  static void gdlGetDesiredAxisTitle(EnvT *e, int axisId, DString &title) {
    int XTITLEIx = e->KeywordIx("XTITLE");
    int YTITLEIx = e->KeywordIx("YTITLE");
    int ZTITLEIx = e->KeywordIx("ZTITLE");
    int choosenIx = XTITLEIx;
    DStructGDL* Struct = NULL;
    if (axisId == XAXIS) {
      Struct = SysVar::X();
      choosenIx = XTITLEIx;
    }
    if (axisId == YAXIS) {
      Struct = SysVar::Y();
      choosenIx = YTITLEIx;
    }
    if (axisId == ZAXIS) {
      Struct = SysVar::Z();
      choosenIx = ZTITLEIx;
    }

    if (Struct != NULL) {
      unsigned titleTag = Struct->Desc()->TagIndex("TITLE");
      title =
        (*static_cast<DStringGDL*> (Struct->GetTag(titleTag, 0)))[0];
    }

    e->AssureStringScalarKWIfPresent(choosenIx, title);
  }

  static void gdlSetLineStyle(EnvT *e, GDLGStream *a) {
    DStructGDL* pStruct = SysVar::P(); //MUST NOT BE STATIC, due to .reset 
    DLong linestyle =
      (*static_cast<DLongGDL*>
      (pStruct->GetTag(pStruct->Desc()->TagIndex("LINESTYLE"), 0)))[0];

    // if the LINESTYLE keyword is present, the value will be change
    DLong linestyleNew = -1111;
    int linestyleIx = e->KeywordIx("LINESTYLE");

    if (e->KeywordSet(linestyleIx)) e->AssureLongScalarKWIfPresent(linestyleIx, linestyleNew);

    bool debug = false;
    if (debug) {
      cout << "temp_linestyle " << linestyleNew << endl;
      cout << "     linestyle " << linestyle << endl;
    }
    if (linestyleNew != -1111) {
      linestyle = linestyleNew;
    }//+1;
    if (linestyle < 0) {
      linestyle = 0;
    }
    if (linestyle > 5) {
      linestyle = 5;
    }
    gdlLineStyle(a, linestyle);
  }

  static DFloat gdlGetPenThickness(EnvT *e, GDLGStream *a) {
    DStructGDL* pStruct = SysVar::P(); //MUST NOT BE STATIC, due to .reset 
    DFloat thick = (*static_cast<DFloatGDL*>
      (pStruct->GetTag(pStruct->Desc()->TagIndex("THICK"), 0)))[0];

    int THICKIx = e->KeywordIx("THICK");
    e->AssureFloatScalarKWIfPresent(THICKIx, thick);
    if (thick <= 0.0) thick = 1.0;
    return thick;
  }

  static void gdlSetPenThickness(EnvT *e, GDLGStream *a) {
    a->Thick(gdlGetPenThickness(e, a));
  }

  static void gdlWriteTitleAndSubtitle(EnvT* e, GDLGStream *a) {
    unsigned titleTag = SysVar::P()->Desc()->TagIndex("TITLE");
    unsigned subTitleTag = SysVar::P()->Desc()->TagIndex("SUBTITLE");
    DString title = (*static_cast<DStringGDL*> (SysVar::P()->GetTag(titleTag, 0)))[0];
    DString subTitle = (*static_cast<DStringGDL*> (SysVar::P()->GetTag(subTitleTag, 0)))[0];

    int TITLEIx = e->KeywordIx("TITLE");
    int SUBTITLEIx = e->KeywordIx("SUBTITLE");
    e->AssureStringScalarKWIfPresent(TITLEIx, title);
    e->AssureStringScalarKWIfPresent(SUBTITLEIx, subTitle);
    if (title.empty() && subTitle.empty()) return;

    gdlSetPlotCharsize(e, a);
    if (!title.empty()) {
      e->AssureStringScalarKWIfPresent(TITLEIx, title);
      gdlSetPlotCharthick(e, a);
      a->sizeChar(1.25 * a->charScale());
      a->mtex("t", 1.5, 0.5, 0.5, title.c_str()); //position is in units of current char height. baseline at half-height
      a->sizeChar(a->charScale() / 1.25);
    }
    if (!subTitle.empty()) {
      e->AssureStringScalarKWIfPresent(SUBTITLEIx, subTitle);
      //      DFloat step=a->mmLineSpacing()/a->mmCharHeight();
      //      a->mtex("b", 5*step, 0.5, 0.5, subTitle.c_str());
      a->mtex("b", 5, 0.5, 0.5, subTitle.c_str()); //position is in units of current char height. baseline at half-height
    }
  }
  //call this function if Y data is strictly >0.
  //set yStart to 0 only if gdlYaxisNoZero is false.

  static bool gdlYaxisNoZero(EnvT* e) {
    //no explict range given?
    DDouble test1, test2;
    unsigned rangeTag = SysVar::Y()->Desc()->TagIndex("RANGE");
    test1 = (*static_cast<DDoubleGDL*> (SysVar::Y()->GetTag(rangeTag, 0)))[0];
    test2 = (*static_cast<DDoubleGDL*> (SysVar::Y()->GetTag(rangeTag, 0)))[1];
    if (!(test1 == 0.0 && test2 == 0.0)) return true;
    int YRANGEIx = e->KeywordIx("YRANGE");

    if (e->KeywordPresent(YRANGEIx)) return true;
    //Style contains 1?
    DLong ystyle;
    gdlGetDesiredAxisStyle(e, YAXIS, ystyle);
    if (ystyle & 1) return true;

    DLong nozero = 0;
    if (ystyle & 16) nozero = 1;
    int YNOZEROIx = e->KeywordIx("YNOZERO");
    if (e->KeywordSet(YNOZEROIx)) nozero = 1;
    return (nozero == 1);
  }


  //advance to next plot unless the noerase flag is set
  // function declared static (local to each function using it) to avoid messing the NOERASEIx index which is not the same.

  static void gdlNextPlotHandlingNoEraseOption(EnvT *e, GDLGStream *a, bool noe = false) {
    bool noErase = false;
    DStructGDL* pStruct = SysVar::P(); //MUST NOT BE STATIC, due to .reset 

    if (!noe) {
      DLong LnoErase = (*static_cast<DLongGDL*>
        (pStruct->
        GetTag(pStruct->Desc()->TagIndex("NOERASE"), 0)))[0];
      noErase = (LnoErase == 1);
      int NOERASEIx = e->KeywordIx("NOERASE");

      if (e->KeywordSet(NOERASEIx)) {
        noErase = true;
      }
    } else {
      noErase = true;
    }

    a->NextPlot(!noErase);
    // all but the first element of !P.MULTI are ignored if POSITION kw or !P.POSITION or !P.REGION is specified
    // TODO: !P.REGION!

    DFloatGDL* pos = NULL;
    DFloatGDL* pos1 = NULL;
    DFloatGDL* pos2 = NULL;

    bool hasregion=false;
    bool hasposition=false;
    // system variable !P.REGION first 
    pos1 = static_cast<DFloatGDL*> (pStruct-> GetTag(pStruct->Desc()->TagIndex("REGION"), 0));
    if ((*pos1)[0] != (*pos1)[2]) hasregion=true;
    
    pos2 = static_cast<DFloatGDL*> (pStruct-> GetTag(pStruct->Desc()->TagIndex("POSITION"), 0));
    if ((*pos2)[0] != (*pos2)[2]) hasposition=true;

    // keyword
    int positionIx = e->KeywordIx("POSITION");
    if (e->GetDefinedKW(positionIx) != NULL) {
      pos = e->GetKWAs<DFloatGDL>(positionIx);
    }
    if (pos != NULL || hasposition || hasregion) a->NoSub();
  }

  //handling of Z bounds is not complete IMHO.

  inline void CheckMargin(GDLGStream* actStream,
    DFloat xMarginL,
    DFloat xMarginR,
    DFloat yMarginB,
    DFloat yMarginT,
    PLFLT& xMR,
    PLFLT& xML,
    PLFLT& yMB,
    PLFLT& yMT) {
    PLFLT sclx = actStream->dCharLength() / actStream->xSubPageSize(); //current char length/subpage size
    xML = xMarginL*sclx; //margin as percentage of subpage
    xMR = xMarginR*sclx;
    PLFLT scly = actStream->dLineSpacing() / actStream->ySubPageSize(); //current char length/subpage size
    yMB = (yMarginB) * scly;
    yMT = (yMarginT) * scly; //to allow subscripts and superscripts (as in IDL)

    if (xML + xMR >= 1.0) {
      PLFLT xMMult = xML + xMR;
      xML /= xMMult * 1.5;
      xMR /= xMMult * 1.5;
    }
    if (yMB + yMT >= 1.0) {
      PLFLT yMMult = yMB + yMT;
      yMB /= yMMult * 1.5;
      yMT /= yMMult * 1.5;
    }
  }
  
  static DDouble gdlSetViewPortAndWorldCoordinates(EnvT* e,
    GDLGStream* actStream,
    DDouble x0,
    DDouble x1,
    bool xLog,
    DDouble y0,
    DDouble y1,
    bool yLog,
    DDouble z0,
    DDouble z1,
    bool zLog,
    DDouble zValue_input, //input
    bool iso = false) {

    DDouble zValue_output;
    COORDSYS coordinateSystem = DATA;
    DDouble xStart, yStart, xEnd, yEnd, zStart, zEnd;

    //work on local values, taking account loginess
    xStart = x0;
    xEnd = x1;
    yStart = y0;
    yEnd = y1;
    zStart = z0;
    zEnd = z1;

    if (xLog) {
      xStart = log10(xStart);
      xEnd = log10(xEnd);
    }
    if (yLog) {
      yStart = log10(yStart);
      yEnd = log10(yEnd);
    }
    if (zLog) {
      zStart = log10(zStart);
      zEnd = log10(zEnd);
    }

    // MARGIN
    DFloat xMarginL, xMarginR, yMarginB, yMarginT, zMarginB, zMarginT; //, zMarginB, zMarginT;
    gdlGetDesiredAxisMargin(e, XAXIS, xMarginL, xMarginR);
    gdlGetDesiredAxisMargin(e, YAXIS, yMarginB, yMarginT);
    gdlGetDesiredAxisMargin(e, ZAXIS, zMarginB, zMarginT);

    PLFLT sxmin,symin,sxmax,symax,szmin,szmax;
    actStream->getSubpageRegion(sxmin,symin,sxmax,symax,&szmin,&szmax);
    //Special for Z: for Z.S, Z.WINDOW and Z.REGION, in case of POSITION having 6 elements

    DDouble zposStart, zposEnd;
    if (std::isfinite(zValue_input)) {
      zposStart=zValue_input;
      zposEnd=ZVALUEMAX;
    } else {
      zposStart=szmin;
      zposEnd=szmax;
    }

    PLFLT xMR, xML, yMB, yMT, zMB, zMT;
    CheckMargin(actStream,
      xMarginL,
      xMarginR,
      yMarginB,
      yMarginT,
      xMR, xML, yMB, yMT);

    // viewport - POSITION overrides
    static PLFLT aspect = 0.0;

    static PLFLT P_position_normed[4] = {0, 0, 0, 0};
    static PLFLT P_region_normed[4] = {0, 0, 0, 0};
    static PLFLT position[4];
    // Set to default values:

    //compute position removing margins
    position[0] = sxmin + xMarginL * actStream->nCharLength();
    position[1] = symin + yMarginB * actStream->nLineSpacing();
    position[2] = sxmax - xMarginR * actStream->nCharLength();
    position[3] = symax - yMarginT * actStream->nLineSpacing();
    DStructGDL* pStruct = SysVar::P(); //MUST NOT BE STATIC, due to .reset 
    // Get !P.position values. !P.REGION is superseded by !P.POSITION
    if (pStruct != NULL) {
      unsigned regionTag = pStruct->Desc()->TagIndex("REGION");
      for (SizeT i = 0; i < 4; ++i) P_region_normed[i] = (PLFLT) (*static_cast<DFloatGDL*> (pStruct->GetTag(regionTag, 0)))[i];
      unsigned positionTag = pStruct->Desc()->TagIndex("POSITION");
      for (SizeT i = 0; i < 4; ++i) P_position_normed[i] = (PLFLT) (*static_cast<DFloatGDL*> (pStruct->GetTag(positionTag, 0)))[i];
    }
    if (P_region_normed[0] != P_region_normed[2]) //exist, so it is a first approx to position: 
    {
      //compute position removing margins
      position[0] = P_region_normed[0] + xMarginL * actStream->nCharLength();
      position[1] = P_region_normed[1] + yMarginB * actStream->nLineSpacing();
      position[2] = P_region_normed[2] - xMarginR * actStream->nCharLength();
      position[3] = P_region_normed[3] - yMarginT * actStream->nLineSpacing();
    }
    if (P_position_normed[0] != P_position_normed[2]) //exist, so it is a second approx to position, this one dos not include margins:
    {
      position[0] = P_position_normed[0];
      position[1] = P_position_normed[1];
      position[2] = P_position_normed[2];
      position[3] = P_position_normed[3];
    }
    //compatibility: Position NEVER outside [0,1]:
    position[0] = max(0.0, position[0]);
    position[1] = max(0.0, position[1]);
    position[2] = min(1.0, position[2]);
    position[3] = min(1.0, position[3]);

    //check presence of DATA,DEVICE and NORMAL options
    int DATAIx = e->KeywordIx("DATA");
    int DEVICEIx = e->KeywordIx("DEVICE");
    int NORMALIx = e->KeywordIx("NORMAL");

    if (e->KeywordSet(DATAIx)) coordinateSystem = DATA;
    if (e->KeywordSet(DEVICEIx)) coordinateSystem = DEVICE;
    if (e->KeywordSet(NORMALIx)) coordinateSystem = NORMAL;

    // read boxPosition if needed
    int positionIx = e->KeywordIx("POSITION");
    DFloatGDL* boxPosition = e->IfDefGetKWAs<DFloatGDL>(positionIx);
    if (boxPosition != NULL) {
      for (SizeT i = 0; i < 4 && i < boxPosition->N_Elements(); ++i) position[i] = (*boxPosition)[i];
      if (boxPosition->N_Elements() > 4) {
        zposStart = fmin((*boxPosition)[4], ZVALUEMAX);
        zposStart = fmax(zposStart, 0);
        if (boxPosition->N_Elements() > 5) {
          zposEnd = fmin((*boxPosition)[5], ZVALUEMAX);
          zposEnd = fmax(zposEnd, 0);
        }
      }
    }
    if (boxPosition != NULL) { //use passed values
      if (coordinateSystem == DEVICE) {
        // modify position to NORMAL if DEVICE is present
        actStream->DeviceToNormedDevice(position[0], position[1], position[0], position[1]);
        actStream->DeviceToNormedDevice(position[2], position[3], position[2], position[3]);
      }
      //compatibility again: Position NEVER outside [0,1]:
      position[0] = max(0.0, position[0]);
      position[1] = max(0.0, position[1]);
      position[2] = min(1.0, position[2]);
      position[3] = min(1.0, position[3]);
    }

    aspect = 0.0; // vpas with aspect=0.0 equals vpor.
    if (iso) aspect = abs((yEnd - yStart) / (xEnd - xStart)); //log-log or lin-log
    bool ret;
    if (iso) ret=actStream->isovpor(position[0], position[2], position[1], position[3], aspect); 
    else  ret=actStream->vpor(position[0], position[2], position[1], position[3]);
    if (ret) e->Throw("Data coordinate system not established.");

    actStream->wind(xStart, xEnd, yStart, yEnd);

    //set ![XYZ].CRANGE ![XYZ].type ![XYZ].WINDOW and ![XYZ].S
    gdlStoreXAxisParameters(actStream, xStart, xEnd, xLog); //already in log here if relevant!
    gdlStoreYAxisParameters(actStream, yStart, yEnd, yLog);
    gdlStoreZAxisParameters(actStream, zStart, zEnd, zLog, zposStart, zposEnd);
    //set P.CLIP (done by PLOT, CONTOUR, SHADE_SURF, and SURFACE)
    gdlStoreCLIP();
    return zposStart;
  }

  
  //gdlAxis will write an axis from Start to End, following all modifier switch, in the good place of the current VPOR, independent of the current WIN,
  // as it is temporarily superseded by setting a new a->win().
  //this makes GDLAXIS independent of WIN, and help the whole code to be dependent only on VPOR which is the sole useful plplot command to really use.
  //ZAXIS will always be an YAXIS plotted with a special YZEXCH T3D matrix. So no special handling of ZAXIS here.
  static void gdlAxis(EnvT *e, GDLGStream *a, int axisId, DDouble Start, DDouble End, bool Log, DLong modifierCode = 0) {
    if (Start==End) return;
    if (Log && (Start<=0 ||End <=0)) return; //important protection 
    DLong Style;
    gdlGetDesiredAxisStyle(e, axisId, Style);
    if ((Style & 4) == 4) return; //if we do not write the axis...
    
    // we WILL plot something, so set temporarlily WIN accordingly
    PLFLT owxmin,owxmax,owymin,owymax;
    a->getCurrentWorldBox(owxmin,owxmax,owymin,owymax);
    if (axisId == XAXIS) {
      if (Log) a->wind(log10(Start),log10(End),owymin,owymax); else a->wind(Start,End,owymin,owymax);
    } else {
      if (Log) a->wind(owxmin,owxmax,log10(Start),log10(End)); else a->wind(owxmin,owxmax,Start,End);
    }
    static GDL_TICKDATA tdata;
    tdata.a = a;
    tdata.isLog = Log;
    tdata.axisrange = abs(End - Start);

    static GDL_TICKNAMEDATA data;
    data.a = a;
    data.isLog = Log;
    data.axisrange = abs(End - Start);
    data.nTickName = 0;

    static GDL_MULTIAXISTICKDATA muaxdata;
    muaxdata.e = e;
    muaxdata.a = a;
    muaxdata.isLog = Log;
    muaxdata.what = GDL_NONE;
    muaxdata.nTickFormat = 0;
    muaxdata.nTickUnits = 0;
    muaxdata.axismin = Start;
    muaxdata.axismax = End;
    muaxdata.axisrange = abs(End - Start);
    muaxdata.reset = true;

    //special values
    PLFLT OtherAxisSizeInMm;
    if (axisId == XAXIS) OtherAxisSizeInMm = a->mmyPageSize()*(a->boxnYSize()); else  OtherAxisSizeInMm = a->mmxPageSize()*(a->boxnXSize());
    DLong GridStyle;
    gdlGetDesiredAxisGridStyle(e, axisId, GridStyle);
    DLong Minor;
    gdlGetDesiredAxisMinor(e, axisId, Minor);
    DFloat Thick;
    gdlGetDesiredAxisThick(e, axisId, Thick);
    DStringGDL* TickFormat;
    gdlGetDesiredAxisTickFormat(e, axisId, TickFormat);
    DDouble TickInterval;
    gdlGetDesiredAxisTickInterval(e, axisId, TickInterval);
    DLong TickLayout;
    gdlGetDesiredAxisTickLayout(e, axisId, TickLayout);
    DFloat TickLen;
    gdlGetDesiredAxisTickLen(e, axisId, TickLen);
    DStringGDL* TickName;
    gdlGetDesiredAxisTickName(e, a, axisId, TickName);
    DDoubleGDL *Tickv = NULL;
    bool hasTickv = gdlGetDesiredAxisTickv(e, axisId, Tickv);
    DLong Ticks;
    gdlGetDesiredAxisTicks(e, axisId, Ticks);
    if (Ticks < 1) hasTickv = false;
    DStringGDL* TickUnits;
    gdlGetDesiredAxisTickUnits(e, axisId, TickUnits);
    DString Title;
    gdlGetDesiredAxisTitle(e, axisId, Title);
    bool hasTitle = (Title.size() > 0);

    bool hasTickUnitDefined = (TickUnits->NBytes() > 0);
    int tickUnitArraySize = (hasTickUnitDefined) ? TickUnits->N_Elements() : 0;

    //For labels we need ticklen in current character size, for ticks we need it in mm
    DFloat ticklen_in_mm = TickLen;
    if (TickLen < 0) ticklen_in_mm *= -1;
    //ticklen in a percentage of box x or y size, to be expressed in mm 
    if (axisId == XAXIS) ticklen_in_mm = a->mmyPageSize()*(a->boxnYSize()) * ticklen_in_mm;
    else ticklen_in_mm = a->mmxPageSize()*(a->boxnXSize()) * ticklen_in_mm;
    DFloat ticklen_as_norm = (axisId == XAXIS) ? a->mm2ndy(ticklen_in_mm) : a->mm2ndx(ticklen_in_mm); //in normed coord
    //eventually, each succesive X or Y axis is separated from previous by interligne + ticklen in adequate units. 
    DFloat interligne_as_char;
    DFloat interligne_as_norm;
    DFloat typical_char_size_mm = (axisId == XAXIS) ? a->mmCharHeight() : a->mmCharLength();
    interligne_as_char = (axisId == XAXIS) ? a->mmLineSpacing() / typical_char_size_mm : a->mmCharLength() / typical_char_size_mm; //in normed coord
    interligne_as_norm = (axisId == XAXIS) ? a->nLineSpacing() : a->nCharLength(); //in normed coord
    DFloat displacement_of_new_axis_as_norm = 2 * interligne_as_norm + ticklen_as_norm;
    DFloat current_displacement = 0;
    DFloat title_position = 0;

    double nchars; //max number of chars written in label of axis. 
    string Opt;
    string otherOpt;
    if (TickInterval == 0) {
      if (Ticks <= 0) TickInterval = gdlComputeTickInterval(e, axisId, Start, End, Log);
      else if (Ticks > 1) TickInterval = (End - Start) / Ticks;
      else TickInterval = (End - Start);
    } else { //check that tickinterval does not make more than 59 ticks:
      if (abs((End - Start) / TickInterval) > 59) TickInterval = (End - Start) / 59;
    }
    if (Minor == 0) {// if tickinterval is 0.1,1,10,100..., IDL wants to see all 10 tickmarks.
      DDouble test = log10(abs(TickInterval));
      if ((test - floor(test)) < std::numeric_limits<DDouble>::epsilon()) Minor = 10;
    }
    //first write labels only:
    gdlSetAxisCharsize(e, a, axisId);
    gdlSetPlotCharthick(e, a);

    //axis, 1st time: labels
    Opt = TICKS YLABEL_VERTICAL NOTICKS;
    otherOpt = TICKS YLABEL_VERTICAL; //draw major ticks "t" + v:values perp to Y axis + x:
    // the x option is in plplot 5.9.8 but not before. It permits
    // to avoid writing tick marks here (they will be written after)
    // I hope old plplots were clever enough to ignore 'x'
    // if they did not understand 'x'
    if (Log) {
      if (TickInterval <= 1) Opt += LOG; //"l" for log; otherOpt is never in log I believe
      //if log and tickinterval was >1 then we pass in 'linear, no subticks' mode (see issue #1112)
    }
    if (TickName->NBytes() > 0) // /TICKNAME=[array]
    {
      data.counter = 0;
      data.nchars = 0;
      data.TickName = TickName;
      data.nTickName = TickName->N_Elements();
      defineLabeling(a, axisId, gdlSingleAxisTickNamedFunc, &data);
      Opt += LABELFUNC; //custom labelling
      if (modifierCode == 2) Opt += NUMERIC_UNCONVENTIONAL; //write label "unconventional position" (top or right) 
      else Opt += NUMERIC; //write label "conventional position" (bottom or left) 
      if (axisId == XAXIS) a->box(Opt.c_str(), TickInterval, Minor, "", 0.0, 0);
      else a->box("", 0.0, 0.0, Opt.c_str(), TickInterval, Minor);
      nchars = data.nchars;
      if (axisId != XAXIS) title_position = nchars + 2.5;
      else title_position = 3.5;
      resetLabeling(a, axisId);
    }      //care Tickunits size is 10 if not defined because it is the size of !X.TICKUNITS.
    else if (hasTickUnitDefined) // /TICKUNITS=[several types of axes written below each other]
    {
      muaxdata.counter = 0;
      muaxdata.what = GDL_TICKUNITS;
      if (TickFormat->NBytes() > 0) // with also TICKFORMAT option..
      {
        muaxdata.what = GDL_TICKFORMAT_AND_UNITS;
        muaxdata.TickFormat = TickFormat;
        muaxdata.nTickFormat = TickFormat->N_Elements();
      }
      muaxdata.TickUnits = TickUnits;
      muaxdata.nTickUnits = tickUnitArraySize;
      defineLabeling(a, axisId, gdlMultiAxisTickFunc, &muaxdata);
      Opt += LABELFUNC;
      otherOpt += LABELFUNC; //use external func custom labeling
      if (modifierCode == 2) {
        Opt += NUMERIC_UNCONVENTIONAL;
        otherOpt += NUMERIC_UNCONVENTIONAL;
      } else {
        Opt += NUMERIC;
        otherOpt += NUMERIC;
      } //m: write numerical/right above, n: below/left (normal)
      PLFLT un, deux, trois, quatre, xun, xdeux, xtrois, xquatre;
      a->getCurrentNormBox(un, deux, trois, quatre);
      a->getCurrentWorldBox(xun, xdeux, xtrois, xquatre);
      a->smaj(ticklen_in_mm, 1.0);
      for (SizeT i = 0; i < muaxdata.nTickUnits; ++i) //loop on TICKUNITS axis
      {
        muaxdata.nchars = 0; //set nchars to 0, at the end nchars will be the maximum size.
        if (i > 0) Opt = otherOpt + BOTTOM; //supplementary axes are to be wwritten with ticks, no smallticks;
        if (axisId == XAXIS) {
          a->vpor(un, deux, trois - current_displacement, quatre);
          a->wind(xun, xdeux, xtrois, xquatre);
          a->box(Opt.c_str(), TickInterval, Minor, "", 0.0, 0); //to avoid plplot crashes: do not use tickinterval. or recompute it correctly (no too small!)
          title_position = current_displacement / a->nCharHeight() + 3.5;
          current_displacement += displacement_of_new_axis_as_norm; //and the spacing plus the ticklengths
        } else {
          a->vpor(un - current_displacement, deux, trois, quatre);
          a->wind(xun, xdeux, xtrois, xquatre);
          a->box("", 0.0, 0.0, Opt.c_str(), TickInterval, Minor); //to avoid plplot crashes: do not use tickinterval. or recompute it correctly (no too small!)
          nchars = muaxdata.nchars;
          title_position = current_displacement / a->nCharLength() + nchars + 2.5;
          current_displacement += (nchars - 1) * a->nCharLength(); //we'll skip what was written
          current_displacement += displacement_of_new_axis_as_norm; //and the spacing plus the ticklengths
        }
        muaxdata.counter++;
      }
      a->vpor(un, deux, trois, quatre);
      a->wind(xun, xdeux, xtrois, xquatre);
      resetLabeling(a, axisId);
    } else if (TickFormat->NBytes() > 0) //no /TICKUNITS=> only 1 value taken into account
    {
      muaxdata.counter = 0;
      muaxdata.nchars = 0;
      muaxdata.what = GDL_TICKFORMAT;
      muaxdata.TickFormat = TickFormat;
      muaxdata.nTickFormat = 1;
      defineLabeling(a, axisId, gdlMultiAxisTickFunc, &muaxdata);
      Opt += LABELFUNC;
      if (modifierCode == 2) Opt += NUMERIC_UNCONVENTIONAL;
      else Opt += NUMERIC;
      if (axisId == XAXIS) a->box(Opt.c_str(), TickInterval, Minor, "", 0.0, 0);
      else a->box("", 0.0, 0.0, Opt.c_str(), TickInterval, Minor);
      nchars = muaxdata.nchars;
      if (axisId != XAXIS) title_position = nchars + 2;
      else title_position = 3.5;
      resetLabeling(a, axisId);
    } else {
      tdata.nchars = 0;
      defineLabeling(a, axisId, gdlSimpleAxisTickFunc, &tdata);
      Opt += LABELFUNC;
      if (modifierCode == 2) Opt += NUMERIC_UNCONVENTIONAL;
      else Opt += NUMERIC;
      if (axisId == XAXIS) a->box(Opt.c_str(), TickInterval, Minor, "", 0.0, 0);
      else a->box("", 0.0, 0.0, Opt.c_str(), TickInterval, Minor);
      nchars = tdata.nchars;
      if (axisId != XAXIS) title_position = nchars + 2;
      else title_position = 3.5;
      resetLabeling(a, axisId);
    }
    if (hasTitle) {
      if (modifierCode == 0 || modifierCode == 1) {
        if (axisId == XAXIS) a->mtex("b", title_position, 0.5, 0.5, Title.c_str());
        else a->mtex("l", title_position, 0.5, 0.5, Title.c_str());
      } else if (modifierCode == 2) {
        if (axisId == XAXIS) a->mtex("t", title_position, 0.5, 0.5, Title.c_str());
        else a->mtex("r", title_position, 0.5, 0.5, Title.c_str());
      }
    }
    if (TickLayout == 0) {
      a->smaj(ticklen_in_mm, 1.0); //set base ticks to default 0.02 viewport converted to mm.
      //a->smin(ticklen_in_mm / 2.0, 1.0); //idem min (plplt defaults) //NO NO NO
      //thick for box and ticks.
      a->Thick(Thick);

      //ticks or grid eventually with style and length:
      if (abs(TickLen) < 1e-6) Opt = "";
      else Opt = TICKS; //remove ticks if ticklen=0
      if (TickLen < 0) {
        Opt += TICKINVERT;
        TickLen = -TickLen;
      }
      switch (modifierCode) {
        case 2:
          Opt += TOP;
          break;
        case 1:
          Opt += BOTTOM;
          break;
        case 0:
          if ((Style & 8) == 8) Opt += BOTTOM;
          else Opt += BOTTOM TOP;
      }
      //gridstyle applies here:
      gdlLineStyle(a, GridStyle);
      if (Log) {
        if (TickInterval < 1) { //if log and tickinterval was >1 then we pass in 'linear, no subticks' mode (see issue #1112)
          if (hasTickv) Opt += LOG;
          else Opt += SUBTICKS LOG;
          Minor = 0;
        } else if (TickInterval < 2) {
          Minor = 1;
        } else if (TickInterval < 2.1) {
          if (!hasTickv) Opt += SUBTICKS;
          Minor = 2;
        } else if (TickInterval < 5.1) {
          if (!hasTickv) Opt += SUBTICKS;
          Minor = 5;
        } else {
          if (!hasTickv) Opt += SUBTICKS;
          Minor = 10;
        }
      } else if (!hasTickv) Opt += SUBTICKS;
      if (axisId == XAXIS) a->box(Opt.c_str(), TickInterval, Minor, "", 0.0, 0);
      else a->box("", 0.0, 0, Opt.c_str(), TickInterval, Minor);
      //reset gridstyle
      gdlLineStyle(a, 0);
      // pass over with outer box, with thick. No style applied, only ticks
      Opt = " ";
      switch (modifierCode) {
        case 2:
          Opt += TOP;
          break;
        case 1:
          Opt += BOTTOM;
          break;
        case 0:
          if ((Style & 8) == 8) Opt += TOP;
          else Opt += BOTTOM TOP;
      }
      if (axisId == XAXIS) a->box(Opt.c_str(), 0.0, 0, "", 0.0, 0);
      else a->box("", 0.0, 0, Opt.c_str(), 0.0, 0);
    }
    gdlWriteDesiredAxisTickGet(e, axisId, Log);
    //reset charsize & thick
    a->Thick(1.0);
    a->sizeChar(1.0);
    a->wind(owxmin,owxmax,owymin,owymax); //restore old values 
  }

  static void gdlBox(EnvT *e, GDLGStream *a, DDouble xStart, DDouble xEnd, bool xLog, DDouble yStart, DDouble yEnd, bool yLog) {
    gdlWriteTitleAndSubtitle(e, a);
    gdlAxis(e, a, XAXIS, xStart, xEnd, xLog);
    gdlAxis(e, a, YAXIS, yStart, yEnd, yLog);
  }
  
  static void gdlBox3(EnvT *e, GDLGStream *a, DDouble xStart, DDouble xEnd, bool xLog, DDouble yStart, DDouble yEnd, bool yLog,  DDouble zStart, DDouble zEnd, bool zLog, DDouble zValue) {
    gdlWriteTitleAndSubtitle(e, a);
    gdlAxis(e, a, XAXIS, xStart, xEnd, xLog, 1); //only Bottom
    gdlAxis(e, a, YAXIS, yStart, yEnd, yLog, 1); //only left

    PLFLT xnormmin, xnormmax, ynormmin, ynormmax, znormmin=0, znormmax=1;
    a->getCurrentNormBox(xnormmin, xnormmax, ynormmin, ynormmax);
    gdlGetCurrentAxisWindow(ZAXIS, znormmin, znormmax);

    //almost cut and paste of plotting_axis section on Z axis:
    PLFLT yPos = ynormmax;
    PLFLT xPos = xnormmin ;
    PLFLT viewportXSize=xnormmax-xPos; if (viewportXSize<0.001) viewportXSize=0.01;
    a->vpor(xPos, xPos + viewportXSize, znormmin, znormmax);
    //special transform to use 'y' axis code, but with 'z' values and yz exch.
    gdlSetZto3DDriverTransform(a, yPos);
    gdlExchange3DDriverTransform(a);
    gdlAxis(e, a, ZAXIS, zStart, zEnd, zLog, 1);

    //restore (normally not useful?)
    gdlExchange3DDriverTransform(a);
    gdlSetZto3DDriverTransform(a, zValue);
    a->vpor(xnormmin, xnormmax, ynormmin, ynormmax);
    a->wind(xStart, xEnd, xLog, yStart, yEnd, yLog); //Y
  }
   
  //restore current clipbox, make another or remove it at all.
  static void gdlSwitchToClippedNormalizedCoordinates(EnvT *e, GDLGStream *actStream, bool invertedClipMeaning=false, bool commandHasCoordSys=true ) {
    COORDSYS coordinateSystem = DATA;
    //check presence of DATA,DEVICE and NORMAL options only of command accept them (otherwise assert triggered if in debug mode)
    if (commandHasCoordSys) {
      static int DATAIx = e->KeywordIx("DATA");
      static int DEVICEIx = e->KeywordIx("DEVICE");
      static int NORMALIx = e->KeywordIx("NORMAL");
      coordinateSystem = DATA;
      //check presence of DATA,DEVICE and NORMAL options
      if (e->KeywordSet(DATAIx)) coordinateSystem = DATA;
      if (e->KeywordSet(DEVICEIx)) coordinateSystem = DEVICE;
      if (e->KeywordSet(NORMALIx)) coordinateSystem = NORMAL;
    }

    //CLIPPING (or not) is just defining the adequate viewport and world coordinates, all of them normalized since this is what plplot will get in the end.
    //CLIPPING is in NORMAL case triggered by the existence of CLIP keyword, and is not set by GDL if 3D is in use, as IDL does weird things and we cannot clip correctly
    // with the current version of plplot.
    bool doClip,noclip;
    static int NOCLIPIx = e->KeywordIx("NOCLIP");
    if (invertedClipMeaning) {
      noclip = e->BooleanKeywordAbsentOrSet(NOCLIPIx);
    } else {
      noclip = e->BooleanKeywordSet(NOCLIPIx);
    }
    doClip = (!noclip);  

    PLFLT xnormmin = 0;
    PLFLT xnormmax = 1;
    PLFLT ynormmin = 0;
    PLFLT ynormmax = 1;

    if (doClip) {
      //retrieve current clip (default)
      DDouble clipx0, clipy0, clipx1, clipy1;
      gdlGetCLIPXY(clipx0, clipy0, clipx1, clipy1); //in normed
      xnormmin = clipx0;
      xnormmax = clipx1;
      ynormmin = clipy0;
      ynormmax = clipy1;
      //redefine default viewport & world
      //define a default clipbox (DATA coords):
      PLFLT clipBox[4] = {clipx0, clipy0, clipx1, clipy1};
      //clipBox is in NORMALIZED coords
      static int CLIP = e->KeywordIx("CLIP"); //this one may be in other coordinates
      DDoubleGDL* clipBoxGDL = e->IfDefGetKWAs<DDoubleGDL>(CLIP);
      if (clipBoxGDL != NULL && clipBoxGDL->N_Elements() < 4) for (auto i = 0; i < 4; ++i) clipBox[i] = 0; //set clipbox to 0 0 0 0 apparently this is what IDL does.
      if (clipBoxGDL != NULL && clipBoxGDL->N_Elements() == 4)
      {
        for (auto i = 0; i < 4; ++i) clipBox[i] = (*clipBoxGDL)[i];
        //newClipBox is defined accordingly to /NORM /DEVICE /DATA:
        //convert newClipBox to normalized coordinates:
        ConvertToNormXY(1, &clipBox[0], false, &clipBox[1], false, coordinateSystem);
        ConvertToNormXY(1, &clipBox[2], false, &clipBox[3], false, coordinateSystem);
        xnormmin = clipBox[0];
        xnormmax = clipBox[2];
        ynormmin = clipBox[1];
        ynormmax = clipBox[3];
      }
    }
    
    bool ret=actStream->vpor(xnormmin, xnormmax, ynormmin, ynormmax);
    if (ret) e->Throw("Data coordinate system not established.");
    actStream->wind(xnormmin, xnormmax, ynormmin, ynormmax); //transformed (plotted) coords will be in NORM. Conversion will be made on the data values.
    }
} // namespace

#endif
